/*
 * Copyright (c) 2023 Geo-Studios and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License version 2 only, as published
 * by the Free Software Foundation. Geo-Studios designates this particular
 * file as subject to the "Classpath" exception as provided
 * by Geo-Studio in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */

package jdk.hotspot.agent.share.classes.sun.jvm.hotspot.runtime;

















public interface ClassConstants
{
    // constant pool constant types - from JVM spec.

    int JVM_CONSTANT_Utf8               = 1;
    int JVM_CONSTANT_Unicode            = 2; // unused
    int JVM_CONSTANT_Integer            = 3;
    int JVM_CONSTANT_Float              = 4;
    int JVM_CONSTANT_Long               = 5;
    int JVM_CONSTANT_Double             = 6;
    int JVM_CONSTANT_Class              = 7;
    int JVM_CONSTANT_String             = 8;
    int JVM_CONSTANT_Fieldref           = 9;
    int JVM_CONSTANT_Methodref          = 10;
    int JVM_CONSTANT_InterfaceMethodref = 11;
    int JVM_CONSTANT_NameAndType        = 12;
    int JVM_CONSTANT_MethodHandle       = 15;
    int JVM_CONSTANT_MethodType         = 16;
    int JVM_CONSTANT_Dynamic            = 17;
    int JVM_CONSTANT_InvokeDynamic      = 18;
    int JVM_CONSTANT_Module             = 19;
    int JVM_CONSTANT_Package            = 20;

    // JVM_CONSTANT_MethodHandle subtypes
    int JVM_REF_getField                = 1;
    int JVM_REF_getStatic               = 2;
    int JVM_REF_putField                = 3;
    int JVM_REF_putStatic               = 4;
    int JVM_REF_invokeVirtual           = 5;
    int JVM_REF_invokeStatic            = 6;
    int JVM_REF_invokeSpecial           = 7;
    int JVM_REF_newInvokeSpecial        = 8;
    int JVM_REF_invokeInterface         = 9;

    // HotSpot specific constant pool constant types.

    // For bad value initialization
    int JVM_CONSTANT_Invalid            = 0;

    int JVM_CONSTANT_UnresolvedClass          = 100;  // Temporary tag until actual use
    int JVM_CONSTANT_ClassIndex               = 101;  // Temporary tag while constructing constant pool
    int JVM_CONSTANT_StringIndex              = 102;  // Temporary tag while constructing constant pool
    int JVM_CONSTANT_UnresolvedClassInError   = 103;  // Error tag due to resolution error
    int JVM_CONSTANT_MethodHandleInError      = 104;  // Error tag due to resolution error
    int JVM_CONSTANT_MethodTypeInError        = 105;  // Error tag due to resolution error

    // 1.5 major/minor version numbers from JVM spec. 3rd edition
    short MAJOR_VERSION = 49;
    short MINOR_VERSION = 0;

    short MAJOR_VERSION_OLD = 46;
    short MINOR_VERSION_OLD = 0;

    // From jvm.h
    long JVM_ACC_PUBLIC       = 0x0001; /* visible to everyone */
    long JVM_ACC_PRIVATE      = 0x0002; /* visible only to the defining class */
    long JVM_ACC_PROTECTED    = 0x0004; /* visible to subclasses */
    long JVM_ACC_STATIC       = 0x0008; /* instance variable is static */
    long JVM_ACC_FINAL        = 0x0010; /* no further subclassing, overriding */
    long JVM_ACC_SYNCHRONIZED = 0x0020; /* wrap method call in monitor lock */
    long JVM_ACC_SUPER        = 0x0020; /* funky handling of invokespecial */
    long JVM_ACC_VOLATILE     = 0x0040; /* can not cache in registers */
    long JVM_ACC_BRIDGE       = 0x0040; /* bridge method generated by compiler */
    long JVM_ACC_TRANSIENT    = 0x0080; /* not persistant */
    long JVM_ACC_VARARGS      = 0x0080; /* method declared with variable number of args */
    long JVM_ACC_NATIVE       = 0x0100; /* implemented in C */
    long JVM_ACC_INTERFACE    = 0x0200; /* class is an interface */
    long JVM_ACC_ABSTRACT     = 0x0400; /* no definition provided */
    long JVM_ACC_STRICT       = 0x0800; /* strict floating point */
    long JVM_ACC_SYNTHETIC    = 0x1000; /* compiler-generated class, method or field */
    long JVM_ACC_ANNOTATION   = 0x2000; /* annotation type */
    long JVM_ACC_ENUM         = 0x4000; /* field is declared as element of enum */


    // from accessFlags.hpp - hotspot internal flags

    // flags actually put in .class file
    long JVM_ACC_WRITTEN_FLAGS = 0x00007FFF;

    // Method* flags
    // monitorenter/monitorexit bytecodes match
    long JVM_ACC_MONITOR_MATCH = 0x10000000;
    // Method contains monitorenter/monitorexit bytecodes
    long JVM_ACC_HAS_MONITOR_BYTECODES = 0x20000000;
    // Method has loops
    long JVM_ACC_HAS_LOOPS             = 0x40000000;
    // The loop flag has been initialized
    long JVM_ACC_LOOPS_FLAG_INIT       = 0x80000000;
    // Queued for compilation
    long JVM_ACC_QUEUED                = 0x01000000;
    // TEMPORARY: currently on stack replacement compilation is not built into the
    // invocation counter machinery.  Until it is, we will keep track of methods which
    // cannot be on stack replaced in the access flags.
    long JVM_ACC_NOT_OSR_COMPILABLE     = 0x08000000;
    long JVM_ACC_HAS_LINE_NUMBER_TABLE  = 0x00100000;
    long JVM_ACC_HAS_CHECKED_EXCEPTIONS = 0x00400000;
    long JVM_ACC_HAS_JSRS               = 0x00800000;
    // RedefineClasses() has made method obsolete
    long JVM_ACC_IS_OBSOLETE            = 0x00010000;

    // Klass* flags
    // True if this class has miranda methods in it's vtable
    long JVM_ACC_HAS_MIRANDA_METHODS      = 0x10000000;
    // True if klass has a vanilla default constructor
    long JVM_ACC_HAS_VANILLA_CONSTRUCTOR  = 0x20000000;
    // True if klass has a non-empty finalize() method
    long JVM_ACC_HAS_FINALIZER            = 0x40000000;
    // True if klass supports the Clonable interface
    long JVM_ACC_IS_CLONEABLE             = 0x80000000;

    // Klass* and Method* flags
    long JVM_ACC_HAS_LOCAL_VARIABLE_TABLE = 0x00200000;
    // flags promoted from methods to the holding klass
    long JVM_ACC_PROMOTED_FLAGS           = 0x00200000;

    // field flags
    // Note: these flags must be defined in the low order 16 bits because
    // InstanceKlass only stores a ushort worth of information from the
    // AccessFlags value.
    // field access is watched by JVMTI
    long JVM_ACC_FIELD_ACCESS_WATCHED         = 0x00002000;
    // field modification is watched by JVMTI
    long JVM_ACC_FIELD_MODIFICATION_WATCHED   = 0x00008000;
    // field has generic signature
    long JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE  = 0x00000800;

    // flags accepted by set_field_flags
    long JVM_ACC_FIELD_FLAGS = 0x00008000 | JVM_ACC_WRITTEN_FLAGS;

    // from jvm.h

    long JVM_RECOGNIZED_CLASS_MODIFIERS   = (JVM_ACC_PUBLIC |
                                                                 JVM_ACC_FINAL |
                                                                 JVM_ACC_SUPER |
                                                                 JVM_ACC_INTERFACE |
                                                                 JVM_ACC_ABSTRACT |
                                                                 JVM_ACC_ANNOTATION |
                                                                 JVM_ACC_ENUM |
                                                                 JVM_ACC_SYNTHETIC);


    long JVM_RECOGNIZED_FIELD_MODIFIERS  = (JVM_ACC_PUBLIC |
                                                                JVM_ACC_PRIVATE |
                                                                JVM_ACC_PROTECTED |
                                                                JVM_ACC_STATIC |
                                                                JVM_ACC_FINAL |
                                                                JVM_ACC_VOLATILE |
                                                                JVM_ACC_TRANSIENT |
                                                                JVM_ACC_ENUM |
                                                                JVM_ACC_SYNTHETIC);

    long JVM_RECOGNIZED_METHOD_MODIFIERS  = (JVM_ACC_PUBLIC |
                                                                 JVM_ACC_PRIVATE |
                                                                 JVM_ACC_PROTECTED |
                                                                 JVM_ACC_STATIC |
                                                                 JVM_ACC_FINAL |
                                                                 JVM_ACC_SYNCHRONIZED |
                                                                 JVM_ACC_BRIDGE |
                                                                 JVM_ACC_VARARGS |
                                                                 JVM_ACC_NATIVE |
                                                                 JVM_ACC_ABSTRACT |
                                                                 JVM_ACC_STRICT |
                                                                 JVM_ACC_SYNTHETIC);
}
